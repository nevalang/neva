# Neva: A Dataflow Language for Humans, Machines, and an AI-First World

## Origin Story: From Syntax Obsession to Dataflow

My journey started years ago when I was programming in JavaScript and thinking obsessively about what a “perfect” programming language might look like—initially almost entirely from a syntax perspective. I kept asking myself why we were still writing and reading text-based code the same way we had for decades. That question led me to visual programming and the idea that code could be represented as something closer to diagrams than paragraphs of text.

At first, the vision was simple and ambitious: build a visual programming tool that would be as accessible as educational block-based languages, but powerful enough to build real, complex systems. I believed that this was achievable.

Around the same time, I moved into backend development and learned Go. I was exposed to concurrency, channels, goroutines, mutexes, atomics, and CSP-style thinking. In parallel, I discovered flow-based programming: the idea that programs are not sequences of instructions mutating memory, but networks of components with input and output ports that communicate asynchronously via message passing.

It later became obvious that all of these ideas—CSP, actor models, and flow-based programming—were really just different expressions of the same deeper paradigm: dataflow.

At some point, everything clicked. Visual programming plus dataflow plus Go felt like a match made in heaven. That was the conceptual birth of Neva.

---

## The Core Paradigm: Dataflow vs. Control Flow

I eventually came to believe that there are two fundamental programming paradigms.

**Control flow languages** treat a program as something that executes in a strict order. Instructions are processed sequentially. Everything is synchronized by default. Memory is mutated. This model is deeply rooted in von Neumann architecture, assembly, and the lineage of languages like Fortran, C, C++, Java, and Go. Even “functional” languages like Haskell still have control flow at their core. They may be declarative in surface syntax, but they still require reasoning about evaluation order, execution semantics, and scheduling.

**Dataflow** is different. In dataflow, a program is a graph. Execution emerges from the availability of data, not from stepping through instructions. Components operate independently and asynchronously. Messages flow between ports. Parallelism is not something you bolt on—it is the default.

The control-flow model worked fine until we hit multi-core processors. At that point, expressing parallelism became painful. Threads, mutexes, atomics, async/await, and CSP were all attempts to graft dataflow concepts onto a control-flow DNA. That grafting created confusion. These languages are still fundamentally control-flow-first, with dataflow as an advanced feature layered on top.

Neva inverts that. Its DNA is dataflow-first.

---

## Visual Programming as a First-Class Citizen

Visual programming isn’t just a UX choice. It’s grounded in how humans actually think.

The human visual cortex is dramatically better at processing structured visual information than symbolic text. Reading code is an unnatural skill that requires years of training. This is one of the reasons programming is so cognitively expensive.

In real life, we reason about systems in terms of dataflow. Architectural diagrams are boxes connected by arrows. Business processes are flows. Even microservices architectures are essentially dataflow graphs.

Most existing visual programming languages fail because they are either:

* educational toys
* hardware-specific tools like LabVIEW
* control-flow-based systems like Blockly, which fundamentally break visual clarity and implicit parallelism

Neva avoids that trap by being a real programming language first and a visual language second. The visual editor is a projection of a formal dataflow language, not a toy syntax layered on top.

Neva is intentionally **hybrid**:

* Text files for Git, diffs, code review, LSP, and AI tooling
* A visual editor for human reasoning and system-level clarity

If something is hard to read in text, that’s acceptable—because this is not a “normal” language. The visual editor is part of the design, not an afterthought.

---

## Visual Programming in the AI Era

Visual programming becomes dramatically more important in the AI era, not less.

As more production code is generated by LLMs and reviewed only superficially by humans, the primary failure mode is no longer syntax—it is **structural nonsense**. Text is a terrible medium for catching those mistakes at a glance.

A visual dataflow graph acts as a **cognitive checksum**: it allows a human to instantly validate whether the system’s shape, dependencies, and intent make sense, even if they do not fully trust the generated code yet.

In this sense, Neva’s visual layer is not a UX gimmick—it is a **safety and comprehension layer** for AI-generated software.

---

## Go as a High-Level Assembly

I originally tried to support both compilation and interpretation. That was a mistake. Supporting two execution models created massive complexity.

The strategic pivot was to treat **Go as a high-level assembly language**.

Go gives Neva:

* one of the fastest compilers in the world
* cross-compilation out of the box
* a mature runtime and garbage collector
* a powerful standard library
* a massive ecosystem
* predictable performance
* simple deployment

Instead of reinventing all of that, Neva compiles to Go. The Go compiler is effectively Neva’s backend.

This unlocks several advantages:

* Neva’s standard library can be thin wrappers around Go’s stdlib, exposed through a dataflow API
* Neva can interoperate with existing Go code
* Existing Go libraries can be reused
* Neva can be gradually introduced into existing Go codebases, TypeScript-style

Go is the substrate. Neva is the paradigm shift layered on top.

---

## Language Architecture: A Deliberately Small Core

Neva is intentionally simple.

The entire core can be explained in one paragraph:

A program is a module. A module contains packages. Packages are directories with files. Files contain entities. Package scope exists; file scope does not. Public entities are marked with `pub`.

There are only **four entity types**:

1. **Types**

   * numbers, strings, booleans
   * structs, lists, dictionaries
   * custom types
   * generics with constraints
   * a bottom type called `any` that forces explicit casting

2. **Consts**

   * typed
   * immutable
   * compile-time known values

3. **Interfaces**

   * port signatures
   * input ports and output ports with names and types

4. **Components**

   * the main abstraction
   * a component implements an interface
   * a component consists of:

     * an interface
     * nodes (instances of other components)
     * a network (connections between ports)

Nodes are instantiated components.
Connections define how data flows from inputs through sub-nodes to outputs.

That’s it.

There are:

* no variables
* no mutation
* almost no implicit behavior
* almost no type inference
* no code-as-data
* no methods
* no inheritance
* composition over inheritance
* no higher-order components
* no runtime dependency injection

Everything is static. Everything is explicit. Everything is analyzable.

---

## Static Typing, Immutability, and Semantic Analysis

My love for static typing started with TypeScript. That experience fundamentally changed how I thought about programming. I realized that I don’t just love types—I love static semantic analysis in general.

I want a compiler that makes entire classes of mistakes impossible.

Neva’s compiler:

* catches incompatible port connections
* detects missing inputs that would cause deadlocks
* rejects structurally meaningless graphs
* prevents undefined execution paths
* enforces immutability
* enforces explicitness everywhere

This is not Rust-style suffering.
There is no borrow checker war.
The compiler only enforces meaningful constraints.

The result is a language where:

> If it compiles, it works.

And that matters more than theoretical type-system purity.

---

## Tooling Vision: Observability as a Primitive

Neva is not just a language. It’s a **computational microscope**.

It already supports:

* emitting Mermaid diagrams
* emitting 3D diagrams via Three.js
* producing structured execution traces showing:

  * who sent what to whom
  * when it was received
  * how messages propagated through the graph

The long-term vision includes:

* a visual debugger
* breakpoints on connections
* message interception
* value mutation at runtime
* step-by-step replay
* full causal tracing

Execution is not hidden.
It’s a visible, inspectable, replayable event stream.

---

## Developer Experience as the Real Goal

Visual programming and implicit concurrency are not the point.
The real point is **developer experience**.

Neva exists to reduce cognitive load.

Visual programming:

* leverages the visual cortex
* increases comprehension speed
* reduces mental fatigue

Implicit concurrency:

* removes the need to reason about threads and locks
* makes parallelism the default

This is similar to how:

* garbage collectors replaced manual memory management
* automatic transmissions replaced manual gearboxes

The goal is not to eliminate concurrency thinking entirely—that’s utopian—but to make it rare.

Most pipelines can overlap naturally.
Even simple two-node pipelines can process multiple messages concurrently without the user thinking about it.
That should be the default.

---

## AI Alignment: Stabilizing a Chaotic Future

AI changes everything.

* LLMs are non-deterministic by design
* prompt engineering is statistical voodoo
* vibe coding is becoming normal
* AI-generated code is increasingly merged with minimal human review

This creates a dangerous tension.

We are introducing probabilistic chaos into systems that were built on deterministic foundations.
That means the substrate language needs to become more stable, not less.

Neva is accidentally aligned with this future.

It has:

* graph-based structure
* static analyzability
* deterministic execution
* explicit semantics
* readable IRs
* strong validation feedback loops

Neva can act as a **stabilization layer** for an AI-first programming world.

Not just a nicer language.
A safety rail.

---

## Project Reality: Rewrites, Friction, and Philosophical Reset

This project has gone through many circles.

* visual-first
* then text-first
* then syntax obsession
* then grammar design
* then visual editor
* then runtime rewrites
* then another runtime rewrite
* then another architectural wall

I repeatedly hit deep design dead-ends.
Each time, the only way forward was to go back to the beginning and rebuild.

Eventually, I realized the hidden mistake.

I had optimized Neva for textual ergonomics.
I was unconsciously trying to make it look like a “normal” language.
I smuggled control-flow composition into dataflow.
That broke everything.

When I removed those features, everything suddenly made sense again.

The core principle I rediscovered:

> Data must flow and direction must be explicit.
> If it desugars into dataflow, the surface syntax must already be dataflow.
> Any feature that fights visualization is a philosophical violation.

This reset cost months.
But it finally made the architecture feel right.

---

## The Existential Layer: Time, Money, and AI Collapse

I’m not pessimistic.
I’m not a loser.
I’m not failing.

I make about five thousand dollars a month.
I support my wife, my father, and my household.
We live well in Vietnam.

But I am not safe.

AI is moving too fast.
White-collar jobs are at real risk.
The permanent underclass scenario is not science fiction.
I don’t have infinite runway.

I burned six to eight months on failed side projects.
I under-earned massively relative to time invested.
I didn’t advance Neva during that time.

Now I’m watching:

* AI rewrite the economy
* coding become semi-automated
* human attention become the bottleneck

I’m stuck between:

* a massive, beautiful, uncompromising language project
* the need to survive financially
* the fear that I’m running out of time

---

## The Real Question

This is not just:

“How do I finish a programming language?”

It’s:

> How do I move from a universe where Neva dies quietly
> to a universe where it clicks, finds a niche, and becomes inevitable?

That’s the real problem.

---

## Open Uncertainties

* I am still unsure how deeply Neva should integrate LLM tooling into its standard library.
* I am still unsure whether Neva’s first real niche should be:

  * AI pipeline orchestration
  * visual data processing
  * distributed systems
  * education
  * or something else entirely.
* I am still unsure whether this is visionary timing or tragic mistiming.

But I am no longer unsure that the architecture itself is coherent.
