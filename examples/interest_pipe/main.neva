import {
	fmt
	runtime
	sync
}

type State struct {
	rate int
	balance int
	last_time int
}

// Avoid overload ambiguity by binding directly to int arithmetic externs.
#extern(int_mul)
def MulInt(left int, right int) (res int)

def Main(start any) (stop any) {
	init InitialDeposit
	calc InterestCalc
	change_rate RateChange
	change_balance BalanceChange
	p1 fmt.Println<int>
	p2 fmt.Println<int>
	p3 fmt.Println<int>
	wg sync.WaitGroup
	panic runtime.Panic
	---
	:start -> [
		3 -> wg:count,
		5 -> init:rate,
		1000 -> init:balance,
		0 -> init:now,
		1 -> calc:now,
		6 -> change_rate:new_rate,
		2 -> change_rate:now,
		1200 -> change_balance:new_balance,
		3 -> change_balance:now
	]

	init:state -> calc:state
	calc:state -> change_rate:state
	change_rate:state -> change_balance:state

	calc:interest -> p1
	change_rate:interest -> p2
	change_balance:interest -> p3
	[p1:res, p2:res, p3:res] -> wg:sig
	wg -> :stop
	[p1:err, p2:err, p3:err] -> panic
}

def InitialDeposit(rate int, balance int, now int) (
	state State,
	interest int
) {
	builder Struct<State>
	---
	:rate -> builder:rate
	:balance -> builder:balance
	:now -> [
		builder:last_time,
		0 -> :interest
	]
	builder -> :state
}

def InterestCalc(state State, now int) (state State, interest int) {
	builder Struct<State>
	calc ComputeInterest
	---
	:state -> [
		calc:state,
		.rate -> builder:rate,
		.balance -> builder:balance
	]
	:now -> [calc:now, builder:last_time]
	calc -> :interest
	builder -> :state
}

def RateChange(state State, new_rate int, now int) (
	state State,
	interest int
) {
	builder Struct<State>
	calc ComputeInterest
	---
	:state -> [
		calc:state,
		.balance -> builder:balance
	]
	:new_rate -> builder:rate
	:now -> [calc:now, builder:last_time]
	calc -> :interest
	builder -> :state
}

def BalanceChange(state State, new_balance int, now int) (
	state State,
	interest int
) {
	builder Struct<State>
	calc ComputeInterest
	---
	:state -> [
		calc:state,
		.rate -> builder:rate
	]
	:new_balance -> builder:balance
	:now -> [calc:now, builder:last_time]
	calc -> :interest
	builder -> :state
}

def ComputeInterest(state State, now int) (interest int) {
	sub Sub
	mul_rate_balance MulInt
	mul_total MulInt
	---
	:state -> [
		.rate -> mul_rate_balance:left,
		.balance -> mul_rate_balance:right,
		.last_time -> sub:right
	]
	:now -> sub:left
	mul_rate_balance -> mul_total:left
	sub -> mul_total:right
	mul_total -> :interest
}
