import {
	fmt
	runtime
	sync
}

type State struct {
	rate float
	balance float
	last_time float
}

def Main(start any) (stop any) {
	init InitialDeposit
	calc InterestCalc
	change_rate RateChange
	change_balance BalanceChange
	p1 fmt.Println<float>
	p2 fmt.Println<float>
	p3 fmt.Println<float>
	wg sync.WaitGroup
	panic runtime.Panic
	---
	:start -> 3 -> wg:count
	:start -> [
		0.05 -> init:rate,
		1000.0 -> init:balance,
		0.0 -> init:now
	]

	init:state -> calc:state
	:start -> 1.0 -> calc:now

	calc:state -> change_rate:state
	:start -> 0.06 -> change_rate:new_rate
	:start -> 2.0 -> change_rate:now

	change_rate:state -> change_balance:state
	:start -> 1200.0 -> change_balance:new_balance
	:start -> 3.0 -> change_balance:now

	calc:interest -> p1
	change_rate:interest -> p2
	change_balance:interest -> p3
	[p1:res, p2:res, p3:res] -> wg:sig
	wg -> :stop
	[p1:err, p2:err, p3:err] -> panic
}

def InitialDeposit(rate float, balance float, now float) (
	state State,
	interest float,
) {
	builder Struct<State>
	---
	:rate -> builder:rate
	:balance -> builder:balance
	:now -> builder:last_time
	builder -> :state
	:now -> 0.0 -> :interest
}

def InterestCalc(state State, now float) (state State, interest float) {
	builder Struct<State>
	calc ComputeInterest
	---
	:state -> [
		calc:state,
		.rate -> builder:rate,
		.balance -> builder:balance
	]
	:now -> [calc:now, builder:last_time]
	calc -> :interest
	builder -> :state
}

def RateChange(state State, new_rate float, now float) (
	state State,
	interest float,
) {
	builder Struct<State>
	calc ComputeInterest
	---
	:state -> [
		calc:state,
		.balance -> builder:balance
	]
	:new_rate -> builder:rate
	:now -> [calc:now, builder:last_time]
	calc -> :interest
	builder -> :state
}

def BalanceChange(state State, new_balance float, now float) (
	state State,
	interest float,
) {
	builder Struct<State>
	calc ComputeInterest
	---
	:state -> [
		calc:state,
		.rate -> builder:rate
	]
	:new_balance -> builder:balance
	:now -> [calc:now, builder:last_time]
	calc -> :interest
	builder -> :state
}

def ComputeInterest(state State, now float) (interest float) {
	sub Sub
	mul_rate_balance Mul
	mul_total Mul
	---
	:state -> [
		.rate -> mul_rate_balance:left,
		.balance -> mul_rate_balance:right,
		.last_time -> sub:right
	]
	:now -> sub:left
	sub -> mul_total:right
	mul_rate_balance -> mul_total:left
	mul_total -> :interest
}
