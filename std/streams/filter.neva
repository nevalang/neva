import { @:lists }

// Filter filters a stream based on a predicate.
// It produces a new stream containing only the elements that satisfy the predicate.
// Note that the resulting stream will have its elements re-indexed to be continuous.
pub def Filter<T>(data stream<T>) (res stream<T>) {
    split Split<T>{predicate IPredicate<T>}
    s2l lists.FromStream<T>
    l2s FromList<T>
    ---
    :data -> split
    split:then -> s2l -> l2s -> :res
}

// Split splits a stream into two streams based on a predicate.
// Notice that it does not modifies stream item indexes and last flag.
pub def Split<T>(data stream<T>) (then stream<T>, else stream<T>) {
    cond Cond<stream<T>>
    predicate IPredicate<T>
    ---
    :data -> [cond:data, .data -> predicate]
    predicate -> cond:if
    cond:then -> :then
    cond:else -> :else
}

// IPredicate represents a logic that determines if a value satisfies a condition.
// It is used by components like Filter and Split to decide how to process stream elements.
pub interface IPredicate<T>(T) (bool)
