// --- Sources ---

pub type Indexed<T> struct {
    idx int
    data T
}

// FromArray iterates over all array-inport's slots in order
// and produces a stream of messages.
#extern(array_port_to_stream)
pub def FromArray<T>([port] T) (res stream<T>)

// FromList creates a stream from a list by sending each element as a stream item.
#extern(list_to_stream)
pub def FromList<T>(data list<T>) (res stream<T>)

// FromString creates a stream of Unicode code points from input string.
// Each stream item is a single-code-point string (Go rune semantics).
// This intentionally does not iterate bytes: multibyte UTF-8 characters
// must remain whole stream elements.
#extern(string_to_stream)
pub def FromString(data string) (res stream<string>)
// Just creates a single-item stream.
#extern(stream_just)
pub def Just<T>(data T) (res stream<T>)

// FromDict creates a stream of dictionary entries.
// Dictionary iteration order is not guaranteed.
#extern(dict_to_stream)
pub def FromDict<T>(data dict<T>) (res stream<DictEntry<T>>)

// Range sends stream of integers starting and ending with given `from` and `to`.
// It supports negative ranges e.g. `-3, 0`. Integers are decremented in that case.
// It emits stream only after both inports receive messages.
#extern(stream_int_range)
pub def Range(from int, to int) (res stream<int>)

// Enumerate attaches a 0-based index to each Data item in a stream.
#extern(stream_enumerate)
pub def Enumerate<T>(data stream<T>) (res stream<Indexed<T>>)

// IsData returns true when stream item has Data tag.
#extern(stream_is_data)
def IsData<T>(data stream<T>) (res bool)

// IsClose returns true when stream item has Close tag.
#extern(stream_is_close)
def IsClose<T>(data stream<T>) (res bool)

// UnwrapData extracts payload from stream<T>::Data item.
#extern(stream_unwrap_data)
def UnwrapData<T>(data stream<T>) (res T)

// --- Synchronization ---

// Wait blocks until stream close item arrives, then sends a signal.
pub def Wait(data stream<any>) (sig any) {
    del Del
    s Switch<stream<any>>
    ---
    :data -> [
        s:data,
        stream<any>::Close -> s:case[0]
    ]
    s:case[0] -> :sig
    s:else -> del
}

// --- Combinators ---

// Produces a stream of tuples of the form (left, right)
// where left is from the left stream and right is from the right stream.
// Stops when either stream is exhausted.
#extern(stream_zip)
pub def Zip<T, R>(left stream<T>, right stream<R>) (res stream<ZipResult<T, R>>)

pub type ZipResult<T, R> struct {
    left T
    right R
}

// Produces a stream of lists where each list contains items from the
// corresponding positions of the input streams. Stops when any stream is
// exhausted.
#extern(stream_zip_many)
pub def ZipMany<T>([data] stream<T>) (res stream<list<T>>)

// Product waits for each input stream to complete,
// then outputs stream of every combination of elements from the first stream with
// elements from the second.
#extern(stream_product)
pub def Product<T, Y>(first stream<T>, second stream<Y>) (res stream<ProductResult<T, Y>>)

pub type ProductResult<T, Y> struct {
    first T
    second Y
}
