// ArrPortToStream iterates over all array-inport's slots in order
// and produces a stream of messages.
#extern(array_port_to_stream)
pub def ArrPortToStream<T>([port] T) (data stream<T>)

// IPortReducer reduces a stream of messages to one single message.
// It's expected to send a result message after every processed stream.
pub interface IPortReducer<T>(stream<T>) (T)

// === Iterators ===

// --- Map ---

// IMapHandler is a dependency for Map.
pub interface IMapHandler<T, Y>(T) (Y)

// Map maps one stream onto another.
// Just like For, it does not block the stream. As soon as one item processed,
// it sends an item downstream and processes the next one.
// It's can receive next message before previous one is processed,
// so it must never be used with side-effects.
pub def Map<T, Y>(data stream<T>) (res stream<Y>) {
    handler IMapHandler<T, Y>
    wrap Struct<stream<Y>>
    ---
    :data -> [
        .idx -> wrap:idx,
        .last -> wrap:last,
        .data -> handler -> wrap:data
    ]
    wrap -> :res
}

// --- For ---

// `For` applies a handler to each item in a stream to produce side-effects.
// It never modifies the stream.
//
// It uses back pressure to ensure the handler processes items sequentially -
// the next item is not sent until the handler signals completion of the previous one.
// This prevents concurrency issues.
//
// Like other iterators, it processes items one at a time without blocking the stream.
// To wait for all items to be processed, use with `streams.Wait`.
pub def For<T>(data stream<T>) (res stream<T>, err error) {
    // IDEA - if we use sync.Step, we don't have to mess with indexes
    
    first First<T> // to check if current msg is the first
    lock1 Lock<stream<T>> // to lock current msg before sending to handler
    lock2 Lock<stream<T>> // to lock current msg before sending downstream
    handler ISideEffector<T>? // to process current msg
    pass1 Pass // to unlock current msg to send to handler
    pass2 Pass // to unlock current msg to send downstream
    ---
    :data -> [lock1:data, lock2:data, first]

    lock1 -> .data -> handler
    lock2 -> :res

    [first:then, pass1] -> lock1:sig
    pass2 -> lock2:sig

    handler:res -> [pass1, pass2]
}

pub interface ISideEffector<T>(T) (res any, err error)

// `First` is a helper that allows to check if given stream item is the first one.
def First<T>(data stream<T>) (then stream<T>, else stream<T>) {
    cond Cond<stream<T>>
    eq Eq<int>
    pass Pass<stream<T>>
    ---
    :data -> [cond:data, pass]
    pass -> .idx -> eq:left
    0 -> eq:right
    eq -> cond:if
    cond:then -> :then
    cond:else -> :else
}

// --- Range ---

// Range sends stream of integers starting and ending with given `from` and `to`.
// It supports negative ranges e.g. `-3, 0`. Integers are decremented in that case.
// It emits stream only after all 3 inports receive messages.
// Signal inport is required because Range is used in range expressions.
#extern(stream_int_range_v2)
pub def Range(from int, to int, sig any) (res stream<int>)
