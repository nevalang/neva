// --- For ---

// `For` applies a handler to each item in a stream to produce side-effects.
// It never modifies the stream.
//
// It uses back pressure to ensure the handler processes items sequentially -
// the next item is not sent until the handler signals completion of the previous one.
// This prevents concurrency issues.
//
// Like other iterators, it processes items one at a time without blocking the stream.
// To wait for all items to be processed, use with `streams.Wait`.
pub def For<T>(data stream<T>) (res stream<T>, err error) {
    // IDEA - if we use sync.Step, we don't have to mess with indexes
    
    first First<T> // to check if current msg is the first
    lock1 Lock<stream<T>> // to lock current msg before sending to handler
    lock2 Lock<stream<T>> // to lock current msg before sending downstream
    handler ISideEffector<T>? // to process current msg
    pass1 Pass // to unlock current msg to send to handler
    pass2 Pass // to unlock current msg to send downstream
    ---
    :data -> [lock1:data, lock2:data, first]

    lock1 -> .data -> handler
    lock2 -> :res

    [first:then, pass1] -> lock1:sig
    pass2 -> lock2:sig

    handler:res -> [pass1, pass2]
}

pub interface ISideEffector<T>(T) (res any, err error)

// `First` is a helper that allows to check if given stream item is the first one.
def First<T>(data stream<T>) (then stream<T>, else stream<T>) {
    cond Cond<stream<T>>
    eq Eq<int>
    pass Pass<stream<T>>
    ---
    :data -> [cond:data, pass]
    pass -> [
        .idx -> eq:left,
        0 -> eq:right
    ]
    eq -> cond:if
    cond:then -> :then
    cond:else -> :else
}
