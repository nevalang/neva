// New emits a message when triggered by a signal.
// It is intended to be used with #bind directive.
// You should prefer constant references and literals over New.
// New requires a trigger signal to prevent buffer overflow.
#extern(new)
pub def New<T>(sig any) (res T)



// Del receives and discards the message.
// You should avoid using it because compiler will insert it automatically
// for every unused outport.
// Del is within small group of components without outports.
#extern(del)
pub def Del(data any) ()

// Lock allows to delay receiving data until a signal arrives.
#extern(lock)
pub def Lock<T>(sig any, data T) (data T)

// Gate forwards a data message only after a `true` event is received on `if`.
//
// - `data` is blocked until a `true` arrives on `if`
// - `false` values on `if` are ignored
// - if `true` never arrives, `data` remains blocked
//
// This component is event-based (latch-like), not pairwise filtering.
pub def Gate<T>(data T, if bool) (res T) {
    if If<T>
    lock Lock<T>
    ---
    :data -> lock:data
    :if -> if
    if:then -> lock:sig
    lock -> :res
}

// FanIn merges several sources of data into single one.
// It makes sure order of incoming messages is respected.
#extern(fan_in)
pub def FanIn<T>([data] T) (res T)

// FanOut is used to broadcast a message from one sender to multiple receivers.
// You should use multiple receivers syntax `-> [...]` instead.
// Multiple receivers is a syntax sugar over explicit FanOut.
#extern(fan_out)
pub def FanOut<T>(data T) ([data] T)

// Struct is used to create structures.
// Inports for Struct are generated by compiler based on provided type argument
// thanks to #autoports directive. This is why it has no inports in source code.
// This is the only component that should use #autoports.
#autoports
#extern(struct_builder)
pub def Struct<T struct {}> () (res T)

// Field is used to access fields of structures.
// You prefer dot notation `-> .<field> ->` instead.
// Dot notation is a syntax sugar for Field.
// Field is unsafe in terms of types because the type system is not sound enough
// to express "each struct with at least these fields".
#extern(field)
pub def Field<T>(data struct {}) (res T)

// Union wraps data into a union tag.
// `tag` must be a union literal constant (literal or const ref) identifying the member.
// `data` must be compatible with the member's type.
#extern(union_wrap)
pub def Union<T Type>(data Type, tag T) (res T)

// Get retrieves a value from a dictionary using the provided key.
// It has two inports: 'dict' for the dictionary and 'key' for the lookup key.
// Sends result to 'res' outport, or error to 'err' if key not found.
#extern(get_dict_value)
pub def Get<T>(dict dict<T>, key T) (res T, err error)

// Pass is used to pass data through. It receives data and sends it to outport.
// E.g. when you want to trigger a constant before fan-in wiring
// and then use it as a sender in fan-in receiver-side:
// :start -> 99 -> pass; [pass, receiver2] -> ...
pub def Pass<T>(data T) (res T) {
    :data -> :res
}

// Sometimes component needs to receive data, perform some action and pass that
// data further. However, due to impossibility to reuse same sender twice or
// more, it leads to need for explicit locks.
// Explicit lock make network harder to reason about.
// `Tap` is a higher-order component, that implements this logic for you.
// All you need to do, is to provide dependency node, that receives data and
// sends a signal when finishes. Signal could be of any type, so no need for
// dealing with locks manually. Handler can send error, in that case `Tap` will
// propagate it up to parent node.
pub def Tap<T>(data T) (res T, err error) {
    handler ITapHandler<T>
    race Race<T>
    del Del
    ---
    :data -> [race:data, handler]
    handler:res -> race:case[0] -> :res
    handler:err -> [race:case[1], :err]
    race:case[1] -> del
}

pub interface ITapHandler<T>(T) (res any, err error)

// Enrich runs a handler and returns both the original input and handler result.
def Enrich<T, Y>(data T) (res EnrichResult<T, Y>, err error) {
    handler ITapHandler<T>
    builder Struct<EnrichResult<T, Y>>
    race Race<T>
    del Del
    ---
    :data -> [race:data, handler]
    handler:res -> [race:case[0], builder:res]
    race:case[0] -> builder:data
    handler:err -> [race:case[1], :err]
    race:case[1] -> del
    builder -> :res
}

// EnrichResult is a structure that holds original input
// and the result of an enrichment operation.
type EnrichResult<T, Y> struct {
    data T
    res Y
}

// IEnrichHandler is an interface for enrich handlers.
interface IEnrichHandler<T, Y>(data T) (res Y, err error)
