// New emits a message in an infinite loop.
// It is inteited to be used with #bind directive.
// You should prefer constant references and literals over New if possible.
// New, just like constant senders, must be used with caution.
// Being infinite, it can easily lead to buffer overflow.
// New is within small group of components without inports.
#extern(new)
pub def New<T>() (res T)

// NewV2 is like New but with `:sig` inport that works like trigger.
#extern(new_v2)
pub def NewV2<T>(sig any) (res T)

// Del receives and discards the message.
// You should avoid using it because compiler will insert it automatically
// for every unused outport.
// Del is within small group of components without outports.
#extern(del)
pub def Del(data any) ()

// Struct is used to create structures.
// Inports for Struct are generated by compiler based on provided type argument
// thanks to #autoports directive. This is why it has no inports in source code.
// This is the only component that should use #autoports.
#autoports
#extern(struct_builder)
pub def Struct<T struct {}> () (res T)

// Field is used to access fields of structures.
// You prefer dot notation `-> .<field> ->` instead.
// Dot notation is a syntax sugar for Field.
// Fiels is unsafe in terms of types just like UnionWrap V1 and V2
// and reasons are exactly the same - type-system is not sound enough
// to express "each struct with at least these fields".
#extern(field)
pub def Field<T>(data struct {}) (res T)

// UnionWrap is used to create union literals.
// It expects that it used with #bind directive,
// that refers to a string constant with the tag name.
// It has one inport "data" where you need to send data to be wrapped.
// It has one outport "res" where you will receive wrapped data from.
// Warning: UnionWrap is not type-safe and should not be used manually if possible.
#extern(union_wrap_v1)
pub def UnionWrapV1<T any, Y union{}>(data T) (res Y)

// UnionWrapV2 is like UnionWrapV1, but it has an extra inport "sig"
// It's main purpose is to support union literals in chained connections.
// Similarly to UnionWrapV1 it's unsafe in terms of types
// and thus should not be used manually if possible.
#extern(union_wrap_v2)
pub def UnionWrapV2<T any, Y union{}>(data T, sig any) (res Y)

// Get retrieves a value from a dictionary using the provided key.
// It has two inports: 'dict' for the dictionary and 'key' for the lookup key.
// Sends result to 'res' outport, or error to 'err' if key not found.
#extern(get_dict_value)
pub def Get<T>(dict dict<T>, key T) (res T, err error)

// Pass is used to pass data through. It receives data and sends it to outport.
// E.g. when you want to trigger a constant from deferred connection
// and then use it as a sender in fan-in receiver-side:
// :start -> 99 -> pass; [pass, receiver2] -> ...
pub def Pass<T>(data T) (res T) {
    :data -> :res
}

// Sometimes component needs to receive data, perform some action and pass that
// data further. However, due to impossibility to reuse same sender twice or
// more, it leads to need for explicit locks. Deferred connections do not cover
// this case. Explicit lock make network harder to reason about.
// `Tap` is a higher-order component, that implements this logic for you.
// All you need to do, is to provide dependency node, that receives data and
// sends a signal when finishes. Signal could be of any type, so no need for
// dealing with locks manually. Handler can send error, in that case `Tap` will
// propagate it up to parent node.
pub def Tap<T>(data T) (res T, err error) {
    handler ITapHandler<T>
    race Race<T>
    del Del
    ---
    :data -> [race:data, handler]
    handler:res -> race:case[0] -> :res
    handler:err -> [race:case[1], :err]
    race:case[1] -> del
}

pub interface ITapHandler<T>(T) (res any, err error)

// Enrich ...
def Enrich<T, Y>(data T) (res EnrichResult, err error) {
    handler ITapHandler<T>
    builder Struct<EnrichResult<T, Y>>
    race Race<T>
    del Del
    ---
    :data -> [race:data, handler]
    handler:res -> [race:case[0], builder:res]
    race:case[0] -> builder:data
    handler:err -> [race:case[1], :err]
    race:case[1] -> del
    builder -> :res
}

// EnrichResult is a structure that holds original input
// and the result of an enrichment operation.
type EnrichResult<T, Y> struct {
    data T
    res Y
}

// IEnrichHandler is an interface for enrich handlers.
interface IEnrichHandler<T, Y>(data T) (res Y, err error)

