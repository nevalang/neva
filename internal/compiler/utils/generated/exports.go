// Code generated by Neva v0.33.0. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"

	"github.com/nevalang/neva/internal/runtime"
	"github.com/nevalang/neva/internal/runtime/funcs"
)

// suppress unused import error, standard go approach for generated code
var _ = fmt.Errorf

type ParseEntityRefInput struct {
	Ref string
}

type ParseEntityRefOutput struct {
	Res runtime.Msg
}

func ParseEntityRef(ctx context.Context, in ParseEntityRefInput) (ParseEntityRefOutput, error) {
	var (
		at_name_2_out_err_to_p2_in_data                   = make(chan runtime.OrderedMsg)
		eq_out_res_to_cond_in_if                          = make(chan runtime.OrderedMsg)
		__new__7_out_res_to_at_name_2_in_idx              = make(chan runtime.OrderedMsg)
		fan_in_pkg_out_res_to_builder_in_pkg              = make(chan runtime.OrderedMsg)
		__fan_out__13_out_data_1_to_at_name_1_in_data     = make(chan runtime.OrderedMsg)
		__fan_out__10_out_data_0_to_split_in_data         = make(chan runtime.OrderedMsg)
		in_ref_to___fan_out__10_in_data                   = make(chan runtime.OrderedMsg)
		__fan_out__10_out_data_1_to_builder_in_metaText   = make(chan runtime.OrderedMsg)
		__new__6_out_res_to_at_pkg_2_in_idx               = make(chan runtime.OrderedMsg)
		at_name_2_out_res_to_fan_in_name_in_data_0        = make(chan runtime.OrderedMsg)
		at_name_1_out_err_to_p3_in_data                   = make(chan runtime.OrderedMsg)
		__fan_out__12_out_data_0_to_at_pkg_2_in_data      = make(chan runtime.OrderedMsg)
		cond_out_else_to___fan_out__13_in_data            = make(chan runtime.OrderedMsg)
		__new__4_out_res_to_split_in_delim                = make(chan runtime.OrderedMsg)
		__fan_out__13_out_data_0_to_lock_empty_pkg_in_sig = make(chan runtime.OrderedMsg)
		__fan_out__11_out_data_1_to_cond_in_data          = make(chan runtime.OrderedMsg)
		__new__8_out_res_to_lock_empty_pkg_in_data        = make(chan runtime.OrderedMsg)
		__fan_out__12_out_data_1_to_at_name_2_in_data     = make(chan runtime.OrderedMsg)
		len_out_res_to_eq_in_left                         = make(chan runtime.OrderedMsg)
		cond_out_then_to___fan_out__12_in_data            = make(chan runtime.OrderedMsg)
		__new__9_out_res_to_at_name_1_in_idx              = make(chan runtime.OrderedMsg)
		__fan_out__11_out_data_0_to_len_in_data           = make(chan runtime.OrderedMsg)
		at_pkg_2_out_res_to_fan_in_pkg_in_data_0          = make(chan runtime.OrderedMsg)
		at_name_1_out_res_to_fan_in_name_in_data_1        = make(chan runtime.OrderedMsg)
		split_out_res_to___fan_out__11_in_data            = make(chan runtime.OrderedMsg)
		at_pkg_2_out_err_to_p1_in_data                    = make(chan runtime.OrderedMsg)
		builder_out_res_to_out_res                        = make(chan runtime.OrderedMsg)
		fan_in_name_out_res_to_builder_in_name            = make(chan runtime.OrderedMsg)
		lock_empty_pkg_out_data_to_fan_in_pkg_in_data_1   = make(chan runtime.OrderedMsg)
		__new__5_out_res_to_eq_in_right                   = make(chan runtime.OrderedMsg)
	)
	interceptor := runtime.ProdInterceptor{}

	var (
		startPort = runtime.NewSingleOutport(
			runtime.PortAddr{Path: "in", Port: "start"},
			interceptor,
			in_ref_to___fan_out__10_in_data,
		)
		stopPort = runtime.NewSingleInport(
			builder_out_res_to_out_res,
			runtime.PortAddr{Path: "out", Port: "stop"},
			interceptor,
		)
	)

	funcCalls := []runtime.FuncCall{
		{
			Ref: "fan_out",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(in_ref_to___fan_out__10_in_data, runtime.PortAddr{Path: "__fan_out__10/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"data": runtime.NewOutport(nil, runtime.NewArrayOutport(runtime.PortAddr{Path: "__fan_out__10/out", Port: "data"}, interceptor, []chan<- runtime.OrderedMsg{__fan_out__10_out_data_0_to_split_in_data, __fan_out__10_out_data_1_to_builder_in_metaText})),
				}),
			},
			Config: nil,
		},
		{
			Ref: "fan_in",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(runtime.NewArrayInport([]<-chan runtime.OrderedMsg{at_pkg_2_out_res_to_fan_in_pkg_in_data_0, lock_empty_pkg_out_data_to_fan_in_pkg_in_data_1}, runtime.PortAddr{Path: "fan_in_pkg/in", Port: "data"}, interceptor), nil),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "fan_in_pkg/out", Port: "res"}, interceptor, fan_in_pkg_out_res_to_builder_in_pkg), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "panic",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(at_pkg_2_out_err_to_p1_in_data, runtime.PortAddr{Path: "p1/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{}),
			},
			Config: nil,
		},
		{
			Ref: "lock",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(__new__8_out_res_to_lock_empty_pkg_in_data, runtime.PortAddr{Path: "lock_empty_pkg/in", Port: "data"}, interceptor)),
					"sig":  runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__13_out_data_0_to_lock_empty_pkg_in_sig, runtime.PortAddr{Path: "lock_empty_pkg/in", Port: "sig"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"data": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "lock_empty_pkg/out", Port: "data"}, interceptor, lock_empty_pkg_out_data_to_fan_in_pkg_in_data_1), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "list_at",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__13_out_data_1_to_at_name_1_in_data, runtime.PortAddr{Path: "at_name_1/in", Port: "data"}, interceptor)),
					"idx":  runtime.NewInport(nil, runtime.NewSingleInport(__new__9_out_res_to_at_name_1_in_idx, runtime.PortAddr{Path: "at_name_1/in", Port: "idx"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"err": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "at_name_1/out", Port: "err"}, interceptor, at_name_1_out_err_to_p3_in_data), nil),
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "at_name_1/out", Port: "res"}, interceptor, at_name_1_out_res_to_fan_in_name_in_data_1), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "fan_in",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(runtime.NewArrayInport([]<-chan runtime.OrderedMsg{at_name_2_out_res_to_fan_in_name_in_data_0, at_name_1_out_res_to_fan_in_name_in_data_1}, runtime.PortAddr{Path: "fan_in_name/in", Port: "data"}, interceptor), nil),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "fan_in_name/out", Port: "res"}, interceptor, fan_in_name_out_res_to_builder_in_name), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "fan_out",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(split_out_res_to___fan_out__11_in_data, runtime.PortAddr{Path: "__fan_out__11/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"data": runtime.NewOutport(nil, runtime.NewArrayOutport(runtime.PortAddr{Path: "__fan_out__11/out", Port: "data"}, interceptor, []chan<- runtime.OrderedMsg{__fan_out__11_out_data_0_to_len_in_data, __fan_out__11_out_data_1_to_cond_in_data})),
				}),
			},
			Config: nil,
		},
		{
			Ref: "new",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "__new__5/out", Port: "res"}, interceptor, __new__5_out_res_to_eq_in_right), nil),
				}),
			},
			Config: runtime.NewIntMsg(2),
		},
		{
			Ref: "list_at",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__12_out_data_1_to_at_name_2_in_data, runtime.PortAddr{Path: "at_name_2/in", Port: "data"}, interceptor)),
					"idx":  runtime.NewInport(nil, runtime.NewSingleInport(__new__7_out_res_to_at_name_2_in_idx, runtime.PortAddr{Path: "at_name_2/in", Port: "idx"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"err": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "at_name_2/out", Port: "err"}, interceptor, at_name_2_out_err_to_p2_in_data), nil),
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "at_name_2/out", Port: "res"}, interceptor, at_name_2_out_res_to_fan_in_name_in_data_0), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "list_len",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__11_out_data_0_to_len_in_data, runtime.PortAddr{Path: "len/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "len/out", Port: "res"}, interceptor, len_out_res_to_eq_in_left), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "fan_out",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(cond_out_then_to___fan_out__12_in_data, runtime.PortAddr{Path: "__fan_out__12/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"data": runtime.NewOutport(nil, runtime.NewArrayOutport(runtime.PortAddr{Path: "__fan_out__12/out", Port: "data"}, interceptor, []chan<- runtime.OrderedMsg{__fan_out__12_out_data_0_to_at_pkg_2_in_data, __fan_out__12_out_data_1_to_at_name_2_in_data})),
				}),
			},
			Config: nil,
		},
		{
			Ref: "new",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "__new__7/out", Port: "res"}, interceptor, __new__7_out_res_to_at_name_2_in_idx), nil),
				}),
			},
			Config: runtime.NewIntMsg(1),
		},
		{
			Ref: "struct_builder",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"metaText": runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__10_out_data_1_to_builder_in_metaText, runtime.PortAddr{Path: "builder/in", Port: "metaText"}, interceptor)),
					"name":     runtime.NewInport(nil, runtime.NewSingleInport(fan_in_name_out_res_to_builder_in_name, runtime.PortAddr{Path: "builder/in", Port: "name"}, interceptor)),
					"pkg":      runtime.NewInport(nil, runtime.NewSingleInport(fan_in_pkg_out_res_to_builder_in_pkg, runtime.PortAddr{Path: "builder/in", Port: "pkg"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "builder/out", Port: "res"}, interceptor, builder_out_res_to_out_res), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "panic",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(at_name_1_out_err_to_p3_in_data, runtime.PortAddr{Path: "p3/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{}),
			},
			Config: nil,
		},
		{
			Ref: "strings_split",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data":  runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__10_out_data_0_to_split_in_data, runtime.PortAddr{Path: "split/in", Port: "data"}, interceptor)),
					"delim": runtime.NewInport(nil, runtime.NewSingleInport(__new__4_out_res_to_split_in_delim, runtime.PortAddr{Path: "split/in", Port: "delim"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "split/out", Port: "res"}, interceptor, split_out_res_to___fan_out__11_in_data), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "fan_out",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(cond_out_else_to___fan_out__13_in_data, runtime.PortAddr{Path: "__fan_out__13/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"data": runtime.NewOutport(nil, runtime.NewArrayOutport(runtime.PortAddr{Path: "__fan_out__13/out", Port: "data"}, interceptor, []chan<- runtime.OrderedMsg{__fan_out__13_out_data_0_to_lock_empty_pkg_in_sig, __fan_out__13_out_data_1_to_at_name_1_in_data})),
				}),
			},
			Config: nil,
		},
		{
			Ref: "new",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "__new__4/out", Port: "res"}, interceptor, __new__4_out_res_to_split_in_delim), nil),
				}),
			},
			Config: runtime.NewStringMsg("."),
		},
		{
			Ref: "new",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "__new__9/out", Port: "res"}, interceptor, __new__9_out_res_to_at_name_1_in_idx), nil),
				}),
			},
			Config: runtime.NewIntMsg(0),
		},
		{
			Ref: "eq",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"left":  runtime.NewInport(nil, runtime.NewSingleInport(len_out_res_to_eq_in_left, runtime.PortAddr{Path: "eq/in", Port: "left"}, interceptor)),
					"right": runtime.NewInport(nil, runtime.NewSingleInport(__new__5_out_res_to_eq_in_right, runtime.PortAddr{Path: "eq/in", Port: "right"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "eq/out", Port: "res"}, interceptor, eq_out_res_to_cond_in_if), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "cond",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__11_out_data_1_to_cond_in_data, runtime.PortAddr{Path: "cond/in", Port: "data"}, interceptor)),
					"if":   runtime.NewInport(nil, runtime.NewSingleInport(eq_out_res_to_cond_in_if, runtime.PortAddr{Path: "cond/in", Port: "if"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"else": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "cond/out", Port: "else"}, interceptor, cond_out_else_to___fan_out__13_in_data), nil),
					"then": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "cond/out", Port: "then"}, interceptor, cond_out_then_to___fan_out__12_in_data), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "list_at",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(__fan_out__12_out_data_0_to_at_pkg_2_in_data, runtime.PortAddr{Path: "at_pkg_2/in", Port: "data"}, interceptor)),
					"idx":  runtime.NewInport(nil, runtime.NewSingleInport(__new__6_out_res_to_at_pkg_2_in_idx, runtime.PortAddr{Path: "at_pkg_2/in", Port: "idx"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"err": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "at_pkg_2/out", Port: "err"}, interceptor, at_pkg_2_out_err_to_p1_in_data), nil),
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "at_pkg_2/out", Port: "res"}, interceptor, at_pkg_2_out_res_to_fan_in_pkg_in_data_0), nil),
				}),
			},
			Config: nil,
		},
		{
			Ref: "panic",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					"data": runtime.NewInport(nil, runtime.NewSingleInport(at_name_2_out_err_to_p2_in_data, runtime.PortAddr{Path: "p2/in", Port: "data"}, interceptor)),
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{}),
			},
			Config: nil,
		},
		{
			Ref: "new",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "__new__6/out", Port: "res"}, interceptor, __new__6_out_res_to_at_pkg_2_in_idx), nil),
				}),
			},
			Config: runtime.NewIntMsg(0),
		},
		{
			Ref: "new",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					"res": runtime.NewOutport(runtime.NewSingleOutport(runtime.PortAddr{Path: "__new__8/out", Port: "res"}, interceptor, __new__8_out_res_to_lock_empty_pkg_in_data), nil),
				}),
			},
			Config: runtime.NewStringMsg(""),
		},
	}

	rprog := runtime.Program{
		Start:     startPort,
		Stop:      stopPort,
		FuncCalls: funcCalls,
	}
	startMsg := runtime.NewStringMsg(in.Ref)

	// Run the program
	res, err := runtime.Call(ctx, rprog, funcs.NewRegistry(), startMsg)
	if err != nil {
		return ParseEntityRefOutput{}, err
	}

	// Parse output message
	var out ParseEntityRefOutput
	if res == nil {
		return out, nil // Should not happen for valid flow
	}
	out.Res = res

	return out, nil
}
