// Package parser implements source code parsing.
// It uses parser (and lexer) generated by ANTLR4 from neva.g4 grammar file.
package parser

import (
	"fmt"
	"runtime/debug"

	"github.com/antlr4-go/antlr/v4"

	"github.com/nevalang/neva/internal/compiler"
	generated "github.com/nevalang/neva/internal/compiler/parser/generated"
	src "github.com/nevalang/neva/pkg/ast"
	"github.com/nevalang/neva/pkg/core"
)

type Parser struct{}

func (p Parser) ParseModules(
	rawMods map[core.ModuleRef]compiler.RawModule,
) (map[core.ModuleRef]src.Module, *compiler.Error) {
	parsedMods := make(map[core.ModuleRef]src.Module, len(rawMods))

	for modRef, rawMod := range rawMods {
		parsedPkgs, err := p.ParsePackages(modRef, rawMod.Packages)
		if err != nil {
			return nil, err
		}

		parsedMods[modRef] = src.Module{
			Manifest: rawMod.Manifest,
			Packages: parsedPkgs,
		}
	}

	return parsedMods, nil
}

func (p Parser) ParsePackages(
	modRef core.ModuleRef,
	rawPkgs map[string]compiler.RawPackage,
) (
	map[string]src.Package,
	*compiler.Error,
) {
	packages := make(map[string]src.Package, len(rawPkgs))

	for pkgName, pkgFiles := range rawPkgs {
		parsedFiles, err := p.ParseFiles(modRef, pkgName, pkgFiles)
		if err != nil {
			return nil, err
		}
		packages[pkgName] = parsedFiles
	}

	return packages, nil
}

func (p Parser) ParseFiles(
	modRef core.ModuleRef,
	pkgName string,
	files map[string][]byte,
) (map[string]src.File, *compiler.Error) {
	result := make(map[string]src.File, len(files))

	for fileName, fileBytes := range files {
		parsedFile, err := p.parseFile(modRef, pkgName, fileName, fileBytes)
		if err != nil {
			if err.Meta == nil {
				err.Meta = &core.Meta{}
			}
			err.Meta.Location = core.Location{
				ModRef:   modRef,
				Package:  pkgName,
				Filename: fileName,
			}
			return nil, err
		}
		result[fileName] = parsedFile
	}

	return result, nil
}

func (p Parser) parseFile(
	modRef core.ModuleRef,
	pkgName string,
	fileName string,
	content []byte,
) (src.File, *compiler.Error) {
	input := antlr.NewInputStream(string(content))
	lexer := generated.NewnevaLexer(input)
	lexerErrors := &CustomErrorListener{}
	lexer.RemoveErrorListeners()
	lexer.AddErrorListener(lexerErrors)
	tokenStream := antlr.NewCommonTokenStream(lexer, 0)

	parserErrors := &CustomErrorListener{}
	prsr := generated.NewnevaParser(tokenStream)
	prsr.RemoveErrorListeners()
	prsr.AddErrorListener(parserErrors)
	prsr.BuildParseTrees = true

	listener := &treeShapeListener{
		loc: core.Location{
			ModRef:   modRef,
			Package:  pkgName,
			Filename: fileName,
		},
	}

	if err := walkTree(listener, prsr.Prog()); err != nil {
		return src.File{}, err
	}

	if len(lexerErrors.Errors) > 0 {
		return src.File{}, lexerErrors.Errors[0]
	}

	if len(parserErrors.Errors) > 0 {
		return src.File{}, parserErrors.Errors[0]
	}

	return listener.state, nil
}

func walkTree(listener antlr.ParseTreeListener, tree antlr.ParseTree) (err *compiler.Error) {
	defer func() {
		if e := recover(); e != nil {
			if compilerErr, ok := e.(*compiler.Error); ok {
				err = compilerErr
				return
			}
			err = &compiler.Error{
				Message: fmt.Sprintf(
					"%v: %v",
					e,
					string(debug.Stack()),
				),
			}
		}
	}()

	antlr.ParseTreeWalkerDefault.Walk(listener, tree)

	return nil
}

func New() Parser {
	return Parser{}
}
