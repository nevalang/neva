import { streams }

def Doer() () {}

pub def Doer() () {}

def Doer() () {}

def Doer<T>(x int) (y T) {}

def Doer<T>(x int) (y T) {
}

def Doer<T>(x int) (y T) {

}

def Doer<T>(x int) (y T) {
}

def Doer<T>(x int) (y T) {
    absNode INode
    ---
}

def Doer<T>(x int) (y T) {
    absNode INode

    ---
}

def Doer<T>(x int) (y T) {

    absNode INode

    ---
}

def Doer<T>(x int) (y T) {
    simpleAbsNode INode
    absNodeWithTypeArgs INode<
        int,
        dict<
            string, vec<bool>
        >
    >
    ---
}

def Doer<T>(x int) (y T) {
    concreteNode  Node
    ---
}

def Doer<T>(x int) (y T) {
    concreteNode  Node
    ---
}

def Doer<T>(x int) (y T) {
    concreteNodeWithTypeArgs  Node<int, vec<string>>
    ---
}

def Doer<T>(x int) (y T) {
    concreteNodeWithDI1  Node1{foo Node2}
    concreteNodeWithDI2  Node1{
        foo Node2
        bar Node3
    }
    ---
}

def Doer<T>(x int) (y T) {
    concreteNodeWithDI1  Node1{
        foo Node2
    }
    concreteNodeWithDI2  Node1{
        foo Node2
        bar Node3
    }
    ---
}

def Doer<T>(x int) (y T) {
    concreteNodeWithDIAndTypeArgs  Node1<
        int,
        dict<
            string,
            vec<bool>
        >
    > {
        foo Node2
        bar Node3
    }
    ---
}

def Doer<T>(x int) (y T) {
    simpleAbsNode INode

    absNodeWithTypeArgs INode<
        int,
        dict<
            string, vec<bool>
        >
    >

    concreteNodeWithDI1  Node1{ foo Node2 }

    concreteNodeWithDIAndTypeArgs  Node1<
        int,
        dict<
            string,
            vec<bool>
        >
    >{
        foo Node2
        bar Node3
    }
    ---
}

def Main(start any) (stop any) {
    abs IReader
    concrete  Scanner
    ---
    :start -> abs:v
    abs:v -> [concrete:v]
    concrete:v -> :code
}

def Main(start any) (stop any) {
    abs IReader
    concrete  Scanner
    ---
    
    :start -> abs:v
    abs:v -> [concrete:v]
    concrete:v -> :code
}

def Main(start any) (stop any) {
    abs IReader
    concrete  Scanner

    ---
    :start -> abs:v
    abs:v -> [concrete:v]
    concrete:v -> :code
}

def Main(start any) (stop any) {
    abs IReader
    concrete  Scanner

    ---

    :start -> abs:v
    abs:v -> [concrete:v]
    concrete:v -> :code
}

def Main() () {
    $foo -> .bar -> foo:bar
    $foo -> .bar.baz -> foo:bar
    foo:bar -> .baz -> foo:bar
    foo:bar -> .baz.bax -> foo:bar
    $foo -> .bar.baz -> [foo:bar, bar:baz]
    foo:bar -> .baz.bax -> [
        foo:bar,
        bar:baz
    ]
}

def Main() () {
    $foo -> { foo:bar -> bar:baz }

    $foo -> [
        { foo:bar -> bar:baz },
        { foo:bar -> bar:baz }
    ]

    $foo -> [
        { foo:bar -> bar:baz },
        { foo:bar -> bar:baz }
    ]

    $foo -> [
        { foo:bar -> bar:baz },
        { foo:bar -> bar:baz }
    ]

    $foo -> [
        { foo:bar -> bar:baz },
        { foo:bar -> bar:baz }
    ]
}

def Main() () {
    $a -> { $b -> { $c -> d:e } }

    $a -> {
        $b -> { $c -> d:e }
    }

    $a -> {
        $b -> {
            $c -> d:e
        }
    }
}

def Main(start any) (stop any) { :start -> :stop }

def Main(start any) (stop any) {
    :start -> :stop }

def Main(start any) (stop any) { :start -> :stop
}

def Main(start any) (stop any) {
    :start -> :stop
}

def Main() () {
    :foo -> :bar
    :baz -> :bax
}

// Test range component
def RangeTest1(start any) (out stream<int>) {
    range streams.Range
    ---
    :start -> [
        1 -> range:from,
        10 -> range:to
    ]
    range -> :out
}

// Test multiple range components
def RangeTest2(start any) (out1 stream<int>, out2 stream<int>) {
    range1 streams.Range
    range2 streams.Range
    ---
    :start -> [
        1 -> range1:from,
        5 -> range1:to,
        10 -> range2:from,
        20 -> range2:to
    ]
    range1 -> :out1

    range2 -> :out2
}

// Test range component with negative numbers
def RangeTest3(start any) (out stream<int>) {
    range streams.Range
    ---
    :start -> [
        -5 -> range:from,
        5 -> range:to
    ]
    range -> :out
}

// Test range component mixed with other connections
def RangeTest4(start any, in any) (out1 stream<int>, out2 any, out3 stream<int>) {
    range1 streams.Range
    range2 streams.Range
    ---
    :start -> [
        1 -> range1:from,
        10 -> range1:to,
        20 -> range2:from,
        30 -> range2:to
    ]
    range1 -> :out1
    :in -> :out2
    range2 -> :out3
}

// Test range component with struct selectors
def RangeTest5(start any) (out stream<int>) {
    range streams.Range
    ---
    :start -> [
        1 -> range:from,
        10 -> range:to
    ]
    range -> .data -> :out
}

// Test range component with array index
def RangeTest6(start any) (out stream<int>) {
    range streams.Range
    ---
    :start -> [
        1 -> range:from,
        10 -> range:to
    ]
    range -> arr[0]
    arr[0] -> :out
}

// Test range component with deferred connection
def RangeTest7(start any) (out stream<int>) {
    range streams.Range
    ---
    :start -> [
        1 -> range:from,
        10 -> range:to
    ]
    range -> { process -> :out }
}

// Test range component with multiple receivers
def RangeTest8(start any) (out1 stream<int>, out2 stream<int>) {
    range streams.Range
    ---
    :start -> [
        1 -> range:from,
        10 -> range:to
    ]
    range -> [:out1, :out2]
}

// Test range component inside deferred connection
def RangeTest9(start any) (out stream<int>) {
    range streams.Range
    ---
    :start -> [
        1 -> range:from,
        10 -> range:to,
        { range -> process -> :out }
    ]
}

// Test range component inside fan-in
def RangeTest10(start any) (out stream<int>) {
    range1 streams.Range
    range2 streams.Range
    range3 streams.Range
    ---
    :start -> [
        1 -> range1:from,
        5 -> range1:to,
        6 -> range2:from,
        10 -> range2:to,
        11 -> range3:from,
        15 -> range3:to
    ]

    [
        range1,
        range2,
        range3
    ] -> fanIn -> :out
}

// Test range component with fan-out
def RangeTest11(start any) (out1 stream<int>, out2 stream<int>, out3 stream<int>) {
    range streams.Range
    ---
    :start -> [
        1 -> range:from,
        30 -> range:to
    ]
    range -> [
        :out1,
        :out2,
        :out3
    ]
}

// Test complex scenario combining multiple features
def RangeTest12(start any, input any) (out1 stream<int>, out2 stream<int>, out3 stream<int>) {
    range1 streams.Range
    range2 streams.Range
    ---
    :start -> [
        1 -> range1:from,
        10 -> range1:to,
        21 -> range2:from,
        30 -> range2:to
    ]

    [range1, :input] -> fanIn -> [
        :out1,
        { process2 -> :out2 },
        range2 -> process3 -> :out3
    ]
}

// Test nested deferred connections with range components
def RangeTest14(start any) (out stream<int>) {
    range1 streams.Range
    range2 streams.Range
    range3 streams.Range
    ---
    :start -> [
        1 -> range1:from,
        5 -> range1:to,
        6 -> range2:from,
        10 -> range2:to,
        11 -> range3:from,
        15 -> range3:to,
        { range1 -> { range2 -> { range3 -> process } } }
    ]
}
