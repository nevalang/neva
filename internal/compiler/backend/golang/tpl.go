package golang

type templateData struct {
	CompilerVersion string
	ChanVarNames    []string
	FuncCalls       []templateFuncCall
	Trace           bool
	TraceComment    string
}

type templateFuncCall struct {
	Ref    string
	Config string
	IO     templateIO
}

type templateIO struct {
	In  map[string]string
	Out map[string]string
}

type libraryTemplateData struct {
	CompilerVersion   string
	Exports           []exportTemplateData
	RuntimeImportPath string
	PackageName       string
}

type exportTemplateData struct {
	Name          string
	InFields      []fieldTemplateData
	OutFields     []fieldTemplateData
	ChanVarNames  []string
	FuncCalls     []templateFuncCall
	Trace         bool
	TraceComment  string
	StartPortChan string
	StopPortChan  string
}

type fieldTemplateData struct {
	Name string // Go struct field name (e.g. "Age")
	Type string // Go type (e.g. "int")
	Port string // Neva port name (e.g. "age")
}

var mainGoTemplate = `// Code generated by Neva v{{.CompilerVersion}}. DO NOT EDIT.
package main

import (
    "fmt"
    "os"
    "context"

    "github.com/nevalang/neva/internal/runtime"
    "github.com/nevalang/neva/internal/runtime/funcs"
)

func main() {
    var (
        {{- range .ChanVarNames}}
        {{.}} = make(chan runtime.OrderedMsg)
        {{- end}}
    )
    {{- if .Trace }}

    interceptor := runtime.NewDebugInterceptor({{printf "%q" .TraceComment}})

    close, err := interceptor.Open("trace.log")
    if err != nil {
        fmt.Fprintln(os.Stderr, "can't open trace file:", err.Error())
        os.Exit(1)
    }
    defer func() {
        if err := close(); err != nil {
            fmt.Fprintln(os.Stderr, "can't close trace file:", err.Error())
            os.Exit(1)
        }
    }()
    {{- else }}

    interceptor := runtime.ProdInterceptor{}
    {{- end }}

    var (
        startPort = runtime.NewSingleOutport(
            runtime.PortAddr{Path: "in", Port: "start"},
            interceptor,
            {{getPortChanNameByAddr "in" "start"}},
        )
        stopPort = runtime.NewSingleInport(
            {{getPortChanNameByAddr "out" "stop"}},
            runtime.PortAddr{Path: "out", Port: "stop"},
            interceptor,
        )
    )

    funcCalls := []runtime.FuncCall{
        {{- range .FuncCalls}}
        {
            Ref: "{{.Ref}}",
            IO: runtime.IO{
                In: runtime.NewInports(map[string]runtime.Inport{
                    {{- range $key, $value := .IO.In}}
                    "{{$key}}": {{$value}},
                    {{- end}}
                }),
                Out: runtime.NewOutports(map[string]runtime.Outport{
                    {{- range $key, $value := .IO.Out}}
                    "{{$key}}": {{$value}},
                    {{- end}}
                }),
            },
            Config: {{.Config}},
        },
        {{- end}}
    }

    rprog := runtime.Program{
        Start: startPort,
        Stop: stopPort,
        FuncCalls: funcCalls,
    }
    
    if err := runtime.Run(context.Background(), rprog, funcs.NewRegistry()); err != nil {
		fmt.Fprintln(os.Stderr, "runtime error:", err.Error())
		os.Exit(1)
	}
}
`

var libraryGoTemplate = `// Code generated by Neva v{{.CompilerVersion}}. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"

	"{{.RuntimeImportPath}}"
	"{{.RuntimeImportPath}}/funcs"
)

// suppress unused import error, standard go approach for generated code
var _ = fmt.Errorf

{{- range .Exports}}

type {{.Name}}Input struct {
	{{- range .InFields}}
	{{.Name}} {{.Type}}
	{{- end}}
}

type {{.Name}}Output struct {
	{{- range .OutFields}}
	{{.Name}} {{.Type}}
	{{- end}}
}

func {{.Name}}(ctx context.Context, in {{.Name}}Input) ({{.Name}}Output, error) {
	var (
		{{- range .ChanVarNames}}
		{{.}} = make(chan runtime.OrderedMsg)
		{{- end}}
	)

	{{- if .Trace }}
	interceptor := runtime.NewDebugInterceptor({{printf "%q" .TraceComment}})
	close, err := interceptor.Open("trace_{{.Name}}.log")
	if err != nil {
		return {{.Name}}Output{}, fmt.Errorf("open trace: %w", err)
	}
	defer func() {
		_ = close()
	}()
	{{- else }}
	interceptor := runtime.ProdInterceptor{}
	{{- end }}

	var (
		startPort = runtime.NewSingleOutport(
			runtime.PortAddr{Path: "in", Port: "start"},
			interceptor,
			{{.StartPortChan}},
		)
		stopPort = runtime.NewSingleInport(
			{{.StopPortChan}},
			runtime.PortAddr{Path: "out", Port: "stop"},
			interceptor,
		)
	)

	funcCalls := []runtime.FuncCall{
		{{- range .FuncCalls}}
		{
			Ref: "{{.Ref}}",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					{{- range $key, $value := .IO.In}}
					"{{$key}}": {{$value}},
					{{- end}}
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					{{- range $key, $value := .IO.Out}}
					"{{$key}}": {{$value}},
					{{- end}}
				}),
			},
			Config: {{.Config}},
		},
		{{- end}}
	}

	rprog := runtime.Program{
		Start: startPort,
		Stop: stopPort,
		FuncCalls: funcCalls,
	}

	{{- if eq (len .InFields) 1}}
	{{- $field := index .InFields 0}}
	startMsg := {{getMsgFromGo "in" $field.Name $field.Type}}
	{{- else}}
	// Prepare input message (StructMsg)
	inFields := []runtime.StructField{
		{{- range .InFields}}
		runtime.NewStructField("{{.Port}}", {{getMsgFromGo "in" .Name .Type}}),
		{{- end}}
	}
	startMsg := runtime.NewStructMsg(inFields)
	{{- end}}

	// Run the program
	res, err := runtime.Call(ctx, rprog, funcs.NewRegistry(), startMsg)
	if err != nil {
		return {{.Name}}Output{}, err
	}

	// Parse output message
	var out {{.Name}}Output
	if res == nil {
		return out, nil // Should not happen for valid flow
	}
	
	{{- if eq (len .OutFields) 1}}
	{{- $field := index .OutFields 0}}
	out.{{$field.Name}} = {{getGoFromMsg "res" $field.Type}}
	{{- else}}
	// We expect a StructMsg as output
	outStruct, ok := res.(runtime.StructMsg)
	if !ok {
		return out, fmt.Errorf("expected StructMsg, got %v", res)
	}

	for name, msg := range outStruct.Map() {
		switch name {
		{{- range .OutFields}}
		case "{{.Port}}":
			out.{{.Name}} = {{getGoFromMsg "msg" .Type}}
		{{- end}}
	}
	{{- end}}

	return out, nil
}
{{- end}}
`
