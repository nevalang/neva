package golang

//nolint:govet // fieldalignment: template grouping.
type templateData struct {
	CompilerVersion string
	ChanVarNames    []string
	FuncCalls       []templateFuncCall
	Trace           bool
	TraceComment    string
	DebugValidation bool
}

//nolint:govet // fieldalignment: template grouping.
type templateFuncCall struct {
	Ref    string
	Config string
	IO     templateIO
}

type templateIO struct {
	In  map[string]string
	Out map[string]string
}

//nolint:govet // fieldalignment: template grouping.
type libraryTemplateData struct {
	CompilerVersion   string
	Exports           []exportTemplateData
	RuntimeImportPath string
	PackageName       string
}

//nolint:govet // fieldalignment: template grouping.
type exportTemplateData struct {
	Name          string
	InFields      []fieldTemplateData
	OutFields     []fieldTemplateData
	ChanVarNames  []string
	FuncCalls     []templateFuncCall
	Trace         bool
	TraceComment  string
	StartPortChan string
	StopPortChan  string
}

type fieldTemplateData struct {
	Name string // Go struct field name (e.g. "Age")
	Type string // Go type (e.g. "int")
	Port string // Neva port name (e.g. "age")
}

var mainGoTemplate = `// Code generated by Neva v{{.CompilerVersion}}. DO NOT EDIT.
package main

import (
    "fmt"
    "os"
    "context"

    "github.com/nevalang/neva/internal/runtime"
    "github.com/nevalang/neva/internal/runtime/funcs"
)

func main() {
    var (
        {{- range .ChanVarNames}}
        {{.}} = make(chan runtime.OrderedMsg)
        {{- end}}
    )
    {{- if .Trace }}

    interceptor := runtime.NewDebugInterceptor({{printf "%q" .TraceComment}})

    close, err := interceptor.Open("trace.log")
    if err != nil {
        fmt.Fprintln(os.Stderr, "can't open trace file:", err.Error())
        os.Exit(1)
    }
    defer func() {
        if err := close(); err != nil {
            fmt.Fprintln(os.Stderr, "can't close trace file:", err.Error())
            os.Exit(1)
        }
    }()
    {{- else }}

    interceptor := runtime.ProdInterceptor{}
    {{- end }}

    var (
        startPort = runtime.NewSingleOutport(
            runtime.PortAddr{Path: "in", Port: "start"},
            interceptor,
            {{getPortChanNameByAddr "in" "start"}},
        )
        stopPort = runtime.NewSingleInport(
            {{getPortChanNameByAddr "out" "stop"}},
            runtime.PortAddr{Path: "out", Port: "stop"},
            interceptor,
        )
    )

    funcCalls := []runtime.FuncCall{
        {{- range .FuncCalls}}
        {
            Ref: "{{.Ref}}",
            IO: runtime.IO{
                In: runtime.NewInports(map[string]runtime.Inport{
                    {{- range $key, $value := .IO.In}}
                    "{{$key}}": {{$value}},
                    {{- end}}
                }),
                Out: runtime.NewOutports(map[string]runtime.Outport{
                    {{- range $key, $value := .IO.Out}}
                    "{{$key}}": {{$value}},
                    {{- end}}
                }),
            },
            Config: {{.Config}},
        },
        {{- end}}
    }

    rprog := runtime.Program{
        Start: startPort,
        Stop: stopPort,
        FuncCalls: funcCalls,
    }
    
    {{- if .DebugValidation }}
    runtime.DebugValidation(rprog)
    {{- end }}

    if err := runtime.Run(context.Background(), rprog, funcs.NewRegistry()); err != nil {
		fmt.Fprintln(os.Stderr, "runtime error:", err.Error())
		os.Exit(1)
	}
}

`

var debugValidationGoTemplate = `package runtime

import "fmt"

// DebugValidation verifies that the program graph is fully connected.
// It is intended for language developers debugging the compiler output.
func DebugValidation(prog Program) {
	type info struct {
		PortSlotAddr
		FuncRef string
		Chan    any
	}

	receivers := map[string]info{}
	senders := map[string]info{}

	for _, call := range prog.FuncCalls {
		for _, inport := range call.IO.In.ports {
			if inport.single != nil {
				k := fmt.Sprint(inport.single.ch)
				receivers[k] = info{
					PortSlotAddr: PortSlotAddr{PortAddr: inport.single.addr},
					FuncRef:      call.Ref,
					Chan:         inport.single.ch,
				}
			} else if inport.array != nil {
				for i, ch := range inport.array.chans {
					k := fmt.Sprint(ch)
					idx := uint8(i)
					receivers[k] = info{
						PortSlotAddr: PortSlotAddr{PortAddr: inport.array.addr, Index: &idx},
						FuncRef:      call.Ref,
						Chan:         ch,
					}
				}
			} else {
				panic("empty func call!")
			}
		}

		for _, outport := range call.IO.Out.ports {
			if outport.single != nil {
				k := fmt.Sprint(outport.single.ch)
				senders[k] = info{
					PortSlotAddr: PortSlotAddr{PortAddr: outport.single.addr},
					FuncRef:      call.Ref,
					Chan:         outport.single.ch,
				}
			} else if outport.array != nil {
				for i, ch := range outport.array.slots {
					k := fmt.Sprint(ch)
					idx := uint8(i)
					senders[k] = info{
						PortSlotAddr: PortSlotAddr{PortAddr: outport.array.addr, Index: &idx},
						FuncRef:      call.Ref,
						Chan:         ch,
					}
				}
			} else {
				panic("empty func call!")
			}
		}
	}

	senders[fmt.Sprint(prog.Start.ch)] = info{
		PortSlotAddr: PortSlotAddr{PortAddr: PortAddr{Path: "prog", Port: "Start"}},
		FuncRef:      "Program",
		Chan:         prog.Start.ch,
	}

	receivers[fmt.Sprint(prog.Stop.ch)] = info{
		PortSlotAddr: PortSlotAddr{PortAddr: PortAddr{Path: "prog", Port: "Stop"}},
		FuncRef:      "Program",
		Chan:         prog.Stop.ch,
	}

	if len(senders) != len(receivers) {
		fmt.Printf(
			"[DEBUG] ===\nWARNING: len(senders)!=len(receivers), senders=%d, receivers=%d\n===\n\n",
			len(senders),
			len(receivers),
		)
	}

	formatSlotIndex := func(idx *uint8) string {
		if idx != nil {
			return fmt.Sprintf("[%d]", *idx)
		}
		return ""
	}

	for senderChanString, sInfo := range senders {
		if _, ok := receivers[senderChanString]; !ok {
			fmt.Printf(
				"[DEBUG] Unconnected Sender: %v | %v:%v%s -> ???\n",
				senderChanString,
				sInfo.PortSlotAddr.Path,
				sInfo.PortSlotAddr.Port,
				formatSlotIndex(sInfo.PortSlotAddr.Index),
			)
		}
	}

	for rChStr, rInfo := range receivers {
		if _, ok := senders[rChStr]; !ok {
			fmt.Printf(
				"[DEBUG] Unconnected Receiver: %v | ??? -> %v:%v%s\n",
				rChStr,
				rInfo.PortSlotAddr.Path,
				rInfo.PortSlotAddr.Port,
				formatSlotIndex(rInfo.PortSlotAddr.Index),
			)
		}
	}
}
`

var libraryGoTemplate = `// Code generated by Neva v{{.CompilerVersion}}. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"

	"{{.RuntimeImportPath}}"
	"{{.RuntimeImportPath}}/funcs"
)

// suppress unused import error, standard go approach for generated code
var _ = fmt.Errorf

{{- range .Exports}}

type {{.Name}}Input struct {
	{{- range .InFields}}
	{{.Name}} {{.Type}}
	{{- end}}
}

type {{.Name}}Output struct {
	{{- range .OutFields}}
	{{.Name}} {{.Type}}
	{{- end}}
}

func {{.Name}}(ctx context.Context, in {{.Name}}Input) ({{.Name}}Output, error) {
	var (
		{{- range .ChanVarNames}}
		{{.}} = make(chan runtime.OrderedMsg)
		{{- end}}
	)

	{{- if .Trace }}
	interceptor := runtime.NewDebugInterceptor({{printf "%q" .TraceComment}})
	close, err := interceptor.Open("trace_{{.Name}}.log")
	if err != nil {
		return {{.Name}}Output{}, fmt.Errorf("open trace: %w", err)
	}
	defer func() {
		_ = close()
	}()
	{{- else }}
	interceptor := runtime.ProdInterceptor{}
	{{- end }}

	var (
		startPort = runtime.NewSingleOutport(
			runtime.PortAddr{Path: "in", Port: "start"},
			interceptor,
			{{.StartPortChan}},
		)
		stopPort = runtime.NewSingleInport(
			{{.StopPortChan}},
			runtime.PortAddr{Path: "out", Port: "stop"},
			interceptor,
		)
	)

	funcCalls := []runtime.FuncCall{
		{{- range .FuncCalls}}
		{
			Ref: "{{.Ref}}",
			IO: runtime.IO{
				In: runtime.NewInports(map[string]runtime.Inport{
					{{- range $key, $value := .IO.In}}
					"{{$key}}": {{$value}},
					{{- end}}
				}),
				Out: runtime.NewOutports(map[string]runtime.Outport{
					{{- range $key, $value := .IO.Out}}
					"{{$key}}": {{$value}},
					{{- end}}
				}),
			},
			Config: {{.Config}},
		},
		{{- end}}
	}

	rprog := runtime.Program{
		Start: startPort,
		Stop: stopPort,
		FuncCalls: funcCalls,
	}

	{{- if eq (len .InFields) 1}}
	{{- $field := index .InFields 0}}
	startMsg := {{getMsgFromGo "in" $field.Name $field.Type}}
	{{- else}}
	// Prepare input message (StructMsg)
	inFields := []runtime.StructField{
		{{- range .InFields}}
		runtime.NewStructField("{{.Port}}", {{getMsgFromGo "in" .Name .Type}}),
		{{- end}}
	}
	startMsg := runtime.NewStructMsg(inFields)
	{{- end}}

	// Run the program
	res, err := runtime.Call(ctx, rprog, funcs.NewRegistry(), startMsg)
	if err != nil {
		return {{.Name}}Output{}, err
	}

	// Parse output message
	var out {{.Name}}Output
	if res == nil {
		return out, nil // Should not happen for valid flow
	}
	
	{{- if eq (len .OutFields) 1}}
	{{- $field := index .OutFields 0}}
	out.{{$field.Name}} = {{getGoFromMsg "res" $field.Type}}
	{{- else}}
	// We expect a StructMsg as output
	outStruct, ok := res.(runtime.StructMsg)
	if !ok {
		return out, fmt.Errorf("expected StructMsg, got %v", res)
	}

	for name, msg := range outStruct.Map() {
		switch name {
		{{- range .OutFields}}
		case "{{.Port}}":
			out.{{.Name}} = {{getGoFromMsg "msg" .Type}}
		{{- end}}
	}
	{{- end}}

	return out, nil
}
{{- end}}
`
